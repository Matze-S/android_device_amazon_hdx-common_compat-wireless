From 37d08f2fca8e1634a655ace10aebb08704eadf19 Mon Sep 17 00:00:00 2001
From: SUraj Sumangala <surajs@qca.qualcomm.com>
Date: Thu, 15 Dec 2011 11:17:37 +0530
Subject: [PATCH 8/8] ath6kl: Add the ath6kl specific callbacks for BT COex
 NL80211 commands

Signed-off-by: Suraj Sumangala <surajs@qca.qualcomm.com>
---
 drivers/net/wireless/ath/ath6kl/cfg80211.c |  117 ++++++++++++++++++++++++++++
 drivers/net/wireless/ath/ath6kl/core.h     |   12 +++
 2 files changed, 129 insertions(+), 0 deletions(-)

diff --git a/drivers/net/wireless/ath/ath6kl/cfg80211.c b/drivers/net/wireless/ath/ath6kl/cfg80211.c
index 3099a5a..b8ec0a5 100644
--- a/drivers/net/wireless/ath/ath6kl/cfg80211.c
+++ b/drivers/net/wireless/ath/ath6kl/cfg80211.c
@@ -2527,6 +2527,118 @@ static int ath6kl_cfg80211_sscan_start(struct wiphy *wiphy,
 	return ret;
 }
 
+#define OP_TYPE_SCO	0x01
+#define OP_TYPE_A2DP	0x02
+#define OP_TYPE_INQUIRY	0x03
+#define OP_TYPE_ESCO	0x04
+
+static int ath6kl_notify_btcoex_inq_status(struct wiphy *wiphy, bool status)
+{
+	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
+	struct ath6kl_vif *vif;
+
+	vif = ath6kl_vif_first(ar);
+	if (!vif)
+		return -EIO;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "BT coex scan status:%d\n", status);
+
+	if (!ath6kl_cfg80211_ready(vif))
+		return -EIO;
+
+	return ath6kl_wmi_set_btcoex_bt_op_status(ar->wmi, OP_TYPE_INQUIRY,
+						   status);
+}
+
+static int ath6kl_notify_btcoex_sco_status(struct wiphy *wiphy,  bool status,
+					    bool esco, u32 tx_interval,
+					    u32 tx_pkt_len)
+{
+	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
+	struct ath6kl_vif *vif;
+
+	vif = ath6kl_vif_first(ar);
+	if (!vif)
+		return -EIO;
+
+	if (!ath6kl_cfg80211_ready(vif))
+		return -EIO;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG,
+		   "BT Coex sco status:%d sco type %s tx interval %d tx pk len %d\n",
+		   status, esco ? "ESCO" : "SCO", tx_interval, tx_pkt_len);
+
+	if (status)
+		ath6kl_wmi_set_btcoex_sco_op(ar->wmi, esco, tx_interval,
+					     tx_pkt_len);
+
+	return ath6kl_wmi_set_btcoex_bt_op_status(ar->wmi, OP_TYPE_SCO,
+						  status);
+}
+
+static int ath6kl_notify_btcoex_a2dp_status(struct wiphy *wiphy, bool status)
+{
+	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
+	struct ath6kl_vif *vif;
+
+	vif = ath6kl_vif_first(ar);
+	if (!vif)
+		return -EIO;
+
+	if (!ath6kl_cfg80211_ready(vif))
+		return -EIO;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "BT coex A2DP status:%d\n", status);
+
+	if (status)
+		ath6kl_wmi_set_btcoex_a2dp_op(ar->wmi,
+					      ar->btcoex_info.acl_role,
+					      ar->btcoex_info.remote_lmp_ver);
+
+	return ath6kl_wmi_set_btcoex_bt_op_status(ar->wmi, OP_TYPE_A2DP,
+						  status);
+}
+
+#define MAX_LMP_VER	6
+static int ath6kl_notify_btcoex_acl_info(struct wiphy *wiphy,
+					  enum nl80211_btcoex_acl_role role,
+					  u32 lmp_ver)
+{
+	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
+
+	if (lmp_ver > MAX_LMP_VER)
+		return -EINVAL;
+
+	if (role > NL80211_BTCOEX_ACL_ROLE_SLAVE)
+		return -EINVAL;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "BT coex ACL role:%d Lmp ver %d\n",
+		   role, lmp_ver);
+
+	ar->btcoex_info.acl_role = role;
+	ar->btcoex_info.remote_lmp_ver = lmp_ver;
+
+	return 0;
+}
+
+#define BTCOEX_COLOCATED_BT_DEFAULT	1
+#define BTCOEX_COLOCATED_BT_QCOM	2
+static int ath6kl_notify_btcoex_antenna_config(struct wiphy *wiphy,
+				enum nl80211_btcoex_antenna_config config)
+{
+	struct ath6kl *ar = (struct ath6kl *)wiphy_priv(wiphy);
+
+	if (config > NL80211_BTCOEX_ANTENNA_SA)
+		return -EINVAL;
+
+	ath6kl_dbg(ATH6KL_DBG_WLAN_CFG, "BT coex Antenna configuration:%d\n",
+		   config);
+	ath6kl_wmi_set_btcoex_set_colocated_bt(ar->wmi,
+					       BTCOEX_COLOCATED_BT_QCOM);
+
+	return ath6kl_wmi_set_btcoex_set_fe_antenna(ar->wmi, config);
+}
+
 static int ath6kl_cfg80211_sscan_stop(struct wiphy *wiphy,
 				      struct net_device *dev)
 {
@@ -2598,6 +2710,11 @@ static struct cfg80211_ops ath6kl_cfg80211_ops = {
 	.cancel_remain_on_channel = ath6kl_cancel_remain_on_channel,
 	.mgmt_tx = ath6kl_mgmt_tx,
 	.mgmt_frame_register = ath6kl_mgmt_frame_register,
+	.notify_btcoex_inq_status = ath6kl_notify_btcoex_inq_status,
+	.notify_btcoex_sco_status = ath6kl_notify_btcoex_sco_status,
+	.notify_btcoex_a2dp_status = ath6kl_notify_btcoex_a2dp_status,
+	.notify_btcoex_acl_info = ath6kl_notify_btcoex_acl_info,
+	.notify_btcoex_antenna_config = ath6kl_notify_btcoex_antenna_config,
 	.sched_scan_start = ath6kl_cfg80211_sscan_start,
 	.sched_scan_stop = ath6kl_cfg80211_sscan_stop,
 };
diff --git a/drivers/net/wireless/ath/ath6kl/core.h b/drivers/net/wireless/ath/ath6kl/core.h
index c863a28..6a69876 100644
--- a/drivers/net/wireless/ath/ath6kl/core.h
+++ b/drivers/net/wireless/ath/ath6kl/core.h
@@ -27,6 +27,7 @@
 #include "wmi.h"
 #include "bmi.h"
 #include "target.h"
+#include "wmi_btcoex.h"
 
 #define MAX_ATH6KL                        1
 #define ATH6KL_MAX_RX_BUFFERS             16
@@ -403,6 +404,15 @@ struct ath6kl_req_key {
 	u8 key_len;
 };
 
+/*
+ * Bluetooth WiFi co-ex information.
+ * This structure keeps track of the Bluetooth related status.
+ * This involves the Bluetooth ACL link role, Bluetooth remote lmp version.
+ */
+struct ath6kl_btcoex {
+	u32 acl_role; /* Master/slave role of Bluetooth ACL link */
+	u32 remote_lmp_ver; /* LMP version of the remote device. */
+};
 enum ath6kl_hif_type {
 	ATH6KL_HIF_TYPE_SDIO,
 	ATH6KL_HIF_TYPE_USB,
@@ -611,6 +621,8 @@ struct ath6kl {
 
 	bool p2p;
 
+	struct ath6kl_btcoex btcoex_info;
+
 #ifdef CONFIG_ATH6KL_DEBUG
 	struct {
 		struct circ_buf fwlog_buf;
-- 
1.7.7.4

